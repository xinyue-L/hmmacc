#' The HMM-based Sleep/Wake Identification Algorithm to identify sustained inactive periods
#'
#' In the sleep/wake identification algorithm, the HMM assumes two states: sleep (state 1)
#' and wake (state 2). As the activity levels follow different distributions under different
#' states, HMM can differentiate the two states accordingly.
#'
#' This function helps identify sustained inactive periods as input for the downstream functions.
#'
#' @import"GGIR"
#' @import"depmixS4"
#' @importFrom"zoo"
#' rollapply
#' @importFrom"zoo"
#' rollmean
#'
#' @param metadatadir Directory that holds a folder ’meta’, which is created after sleep.prep.
#' @param f0 File index to start with (default = 1, and usually working with the default is fine). Index refers to the file names sorted in the increasing order.
#' @param f1 File index to finish with (defaults to the number of files available, and setting to 0 is fine).
#' @param lastdayend A variable to suggest the approximate end time on the last day. Participants often take off the watch early on the last day but the data may continue to be collected and this period may be failed to be detected as non-wear periods. Therefore, lastdayend can help prevent this problem by setting an approximate end time. If lastdayend = 9, then presumably the participant takes off the watch around 9am. The default is NULL.
#' @param nonwearhour Remove the detected nonwear intervals that are shorter than L hours. The default value of \code{L} is 2 (hours).
#' @param ninvalid Remove the days that have < \code{h} hours valid data. The default is \code{h}=16 hours.
#' @param startearly a safeguard to prevent evening nap/take-off period from being identified as sleep onset time. For example, sometimes the shower watch take-off is not identified and removed as a non-wear period, and is then recognized as the sleep onset. If the safeguard startearly = 20, then the marker for sleep start shall be after 20:00/8pm. The default is NULL.
#' @param endearly a safeguard to prevent wake-up at night from being identified as morning wake-up time. For example, if the safeguard endearly = 5, then the marker for sleep end shall be after 5am. The default is NULL.
#' @param ignorenonwear If ignorenonwear=TRUE then ignore detected monitor non-wear periods before identifying sustained inactivity (default = TRUE).
#' @param overwrite Whether to overwrite data that were generated by this function previously. If overwrite = FALSE then it will not overwrite but skip the previously generated files (default = FALSE).
#' @param do.pdf Whether to generate a pdf for sleep quality control visualization. Turning this off could speed up the process.
#' @param do.parallel Whether to use multi-core processing. Parallel processing only works if at least 4 CPU cores are available (default = TRUE).
#' @param desiredtz desired timezone.
#'
#' @keywords inactive periods
#'
#' @return a RData file containing information on sustained inactive periods. No direct output.

#' @examples
#'
#'#metadir = "C:/myfolder/meta" # the meta folder containing the results from previous steps
#'#sleep.part3(metadatadir=metadir, overwrite=TRUE)
#'
#' @export

sleep.part3 <- function (metadatadir = c(), f0=1, f1=0,
                         lastdayend = NULL, nonwearhour = 2, ninvalid = 16, startearly = NULL, endearly = NULL,
                         ignorenonwear = TRUE, overwrite = FALSE,do.pdf = TRUE, do.parallel = TRUE, desiredtz = "", ...)
{
  if (file.exists(paste(metadatadir, sep = ""))) {
  }
  else {
    dir.create(file.path(metadatadir))
  }
  if (file.exists(paste(metadatadir, "/meta/ms3.out.new",
                        sep = ""))) {
  }
  else {
    dir.create(file.path(paste(metadatadir, "/meta",
                               sep = ""), "ms3.out.new"))
    dir.create(file.path(paste(metadatadir, "/meta",
                               sep = ""), "sleep.qc"))
  }
  fnames = dir(paste(metadatadir, "/meta/ms2.out", sep = ""))
  if (f1 > length(fnames) | f1 == 0)
    f1 = length(fnames)
  if (f0 > length(fnames) | f0 == 0)
    f0 = 1
  ffdone = fdone = dir(paste(metadatadir, "/meta/ms3.out.new",
                             sep = ""))
  if (length(fdone) > 0) {
    for (ij in 1:length(fdone)) {
      tmp = unlist(strsplit(fdone[ij], ".RData"))
      ffdone[ij] = tmp[1]
    }
  }
  else {
    ffdone = c()
  }
  nightsperpage = 7
  if (do.parallel == TRUE) {
    closeAllConnections()
    cores = parallel::detectCores()
    Ncores = cores[1]
    if (Ncores > 3) {
      cl <- parallel::makeCluster(Ncores - 1)
      doParallel::registerDoParallel(cl)
    }
    else {
      cat(paste0("\nparallel processing not possible because number of available cores (",
                 Ncores, ") < 4"))
      do.parallel = FALSE
    }
  }
  t1 = Sys.time()
  if (do.parallel == TRUE) {
    cat(paste0("\n Busy processing ... see ", metadatadir,
               "/ms3", " for progress\n"))
  }
  GGIRinstalled = is.element("GGIR", installed.packages()[,
                                                          1])
  packages2passon = functions2passon = NULL
  GGIRloaded = "GGIR" %in% .packages()
  if (GGIRloaded) {
    packages2passon = c("GGIR","depmixS4")
    errhand = "pass"
  }
  else {
    functions2passon = c("g.sib.det", "g.detecmidnight",
                         "iso8601chartime2POSIX", "g.sib.plot",
                         "g.sib.sum","depmix")
    errhand = "stop"
  }
  fe_dopar = foreach::`%dopar%`
  fe_do = foreach::`%do%`
  i = 0
  `%myinfix%` = ifelse(do.parallel, fe_dopar, fe_do)
  output_list = foreach::foreach(i = f0:f1, .packages = packages2passon,
                                 .export = functions2passon, .errorhandling = errhand) %myinfix%
    {
      tryCatchResult = tryCatch({
        FI = file.info(paste(metadatadir, "/meta/ms2.out/",
                             fnames[i], sep = ""))
        if (is.na(FI$size) == TRUE)
          FI$size = 0
        if (FI$size == 0 | is.na(FI$size) == TRUE | length(FI$size) ==
            0) {
          cat(paste("P3 file ", fnames[i], sep = ""))
          cat("Filename not recognised")
        }
        fname = unlist(strsplit(fnames[i], ".RData"))[1]
        if (length(ffdone) > 0) {
          if (length(which(ffdone == fname)) > 0) {
            skip = 1
          }
          else {
            skip = 0
          }
        } else {
          skip = 0
        }
        if (overwrite == TRUE)
          skip = 0
        if (skip == 0) {
          cat(paste(" ", i, sep = ""))
          IMP = M = c()
          load(paste(metadatadir, "/meta/basic/meta_",
                     fnames[i], sep = ""))
          load(paste(metadatadir, "/meta/ms2.out/",
                     fnames[i], sep = ""))
          if (M$filecorrupt == FALSE & M$filetooshort ==
              FALSE) {
            g.sib.det2 <- function(M, IMP, I, twd = c(-12, 12), anglethreshold = 5, timethreshold = 5,
                                    acc.metric = "ENMO", desiredtz = "", constrain2range = TRUE,
                                    dayborder = 0, myfun = c()) {
              perc = 0.1
              inbedthreshold = 15
              bedblocksize = 30
              outofbedsize = 60
              sptwindow_HDCZA = function(angle, k = 60, perc = 0.1, inbedthreshold = 15,
                                         bedblocksize = 30, outofbedsize = 60, ws3 = 5, constrain2range = FALSE) {
                medabsdi = function(angle) {
                  angvar = stats::median(abs(diff(angle)))
                  return(angvar)
                }
                x = zoo::rollapply(angle, k, medabsdi)
                nomov = rep(0, length(x))
                inbedtime = rep(NA, length(x))
                pp = quantile(x, probs = c(perc)) * inbedthreshold
                if (constrain2range == TRUE) {
                  if (pp < 0.13)
                    pp = 0.13
                  if (pp > 0.5)
                    pp = 0.5
                }
                else {
                  if (pp == 0)
                    pp = 0.2
                }
                nomov[which(x < pp)] = 1
                nomov = c(0, nomov, 0)
                s1 = which(diff(nomov) == 1)
                e1 = which(diff(nomov) == -1)
                bedblock = which((e1 - s1) > ((60/ws3) * bedblocksize *
                                                1))
                if (length(bedblock) > 0) {
                  s2 = s1[bedblock]
                  e2 = e1[bedblock]
                  for (j in 1:length(s2)) {
                    inbedtime[s2[j]:e2[j]] = 1
                  }
                  outofbed = rep(0, length(inbedtime))
                  outofbed[which(is.na(inbedtime) == TRUE)] = 1
                  outofbed = c(0, outofbed, 0)
                  s3 = which(diff(outofbed) == 1)
                  e3 = which(diff(outofbed) == -1)
                  outofbedblock = which((e3 - s3) < ((60/ws3) * outofbedsize *
                                                       1))
                  if (length(outofbedblock) > 0) {
                    s4 = s3[outofbedblock]
                    e4 = e3[outofbedblock]
                    if (length(s4) > 0) {
                      for (j in 1:length(s4)) {
                        inbedtime[s4[j]:e4[j]] = 1
                      }
                    }
                  }
                  if (length(inbedtime) == (length(x) + 1))
                    inbedtime = inbedtime[1:(length(inbedtime) -
                                               1)]
                  inbedtime2 = rep(1, length(inbedtime))
                  inbedtime2[which(is.na(inbedtime) == TRUE)] = 0
                  s5 = which(diff(c(0, inbedtime2, 0)) == 1)
                  e5 = which(diff(c(0, inbedtime2, 0)) == -1)
                  inbeddurations = e5 - s5
                  longestinbed = which(inbeddurations == max(inbeddurations))
                  if (length(longestinbed) > 1)
                    longestinbed = longestinbed[ceiling(length(longestinbed)/2)]
                  sptwindow_HDCZA_start = s5[longestinbed] - 1
                  sptwindow_HDCZA_end = e5[longestinbed] - 1
                  if (sptwindow_HDCZA_start == 0)
                    sptwindow_HDCZA_start = 1
                }
                else {
                  sptwindow_HDCZA_end = c()
                  sptwindow_HDCZA_start = c()
                  tib.threshold = c()
                }
                tib.threshold = pp
                invisible(list(sptwindow_HDCZA_start = sptwindow_HDCZA_start,
                               sptwindow_HDCZA_end = sptwindow_HDCZA_end, tib.threshold = tib.threshold))
              }
              dstime_handling_check = function(tmpTIME = tmpTIME, inbedout = inbedout,
                                               tz = c(), calc_sptwindow_HDCZA_end = c(), calc_sptwindow_HDCZA_start = c()) {
                time_sptwindow_HDCZA_start = iso8601chartime2POSIX(tmpTIME[inbedout$sptwindow_HDCZA_start],
                                                                   tz = tz)
                time_sptwindow_HDCZA_end = iso8601chartime2POSIX(tmpTIME[inbedout$sptwindow_HDCZA_end],
                                                                 tz = tz)
                time_sptwindow_HDCZA_end_hr = as.numeric(format(time_sptwindow_HDCZA_end,
                                                                format = "%H"))
                time_sptwindow_HDCZA_start_hr = as.numeric(format(time_sptwindow_HDCZA_start,
                                                                  format = "%H"))
                t0 = as.numeric(format(iso8601chartime2POSIX(tmpTIME[1],
                                                             tz = tz), format = "%H"))
                t1 = as.numeric(format(iso8601chartime2POSIX(tmpTIME[length(tmpTIME)],
                                                             tz = tz), format = "%H"))
                if (is.na(t1) == TRUE | is.na(t0) == TRUE) {
                  time_sptwindow_HDCZA_start = as.POSIXlt(tmpTIME[inbedout$sptwindow_HDCZA_start],
                                                          origin = "1970-01-01", tz = tz)
                  time_sptwindow_HDCZA_end = as.POSIXlt(tmpTIME[inbedout$sptwindow_HDCZA_end],
                                                        origin = "1970-01-01", tz = tz)
                  time_sptwindow_HDCZA_end_hr = as.numeric(format(time_sptwindow_HDCZA_end,
                                                                  format = "%H"))
                  time_sptwindow_HDCZA_start_hr = as.numeric(format(time_sptwindow_HDCZA_start,
                                                                    format = "%H"))
                  t0 = as.numeric(format(as.POSIXlt(tmpTIME[1], origin = "1970-01-01",
                                                    tz = tz), format = "%H"))
                  t1 = as.numeric(format(as.POSIXlt(tmpTIME[length(tmpTIME)],
                                                    origin = "1970-01-01", tz = tz), format = "%H"))
                }
                Nhoursdata = floor(length(tmpTIME)/(3600/ws3))
                delta_t1_t0 = (t1 + 24) - t0
                if (length(time_sptwindow_HDCZA_end_hr) > 0 & length(time_sptwindow_HDCZA_start_hr) >
                    0) {
                  if (Nhoursdata > (delta_t1_t0 + 0.1) & (time_sptwindow_HDCZA_end_hr >
                                                          1 | time_sptwindow_HDCZA_end_hr < 12) & (time_sptwindow_HDCZA_start_hr <
                                                                                                   1 | time_sptwindow_HDCZA_start_hr > 12)) {
                    calc_sptwindow_HDCZA_end = calc_sptwindow_HDCZA_end -
                      1
                  }
                  else if (Nhoursdata + 0.1 < delta_t1_t0 & (time_sptwindow_HDCZA_end_hr >
                                                             1 | time_sptwindow_HDCZA_end_hr < 12) & (time_sptwindow_HDCZA_start_hr <
                                                                                                      1 | time_sptwindow_HDCZA_start_hr > 12)) {
                    calc_sptwindow_HDCZA_end = calc_sptwindow_HDCZA_end +
                      1
                  }
                }
                return(calc_sptwindow_HDCZA_end)
              }
              nD = nrow(IMP$metashort)
              mon = I$monn
              ws3 = M$windowsizes[1]
              ws2 = M$windowsizes[2]
              n_ws2_perday = (1440 * 60)/ws2
              n_ws3_perday = (1440 * 60)/ws3
              Nsleep = length(timethreshold) * length(anglethreshold)
              sleep = matrix(0, nD, Nsleep)
              rout = IMP$rout
              r5 = as.numeric(as.matrix(rout[, 5]))
              r5long = matrix(0, length(r5), (ws2/ws3))
              r5long = replace(r5long, 1:length(r5long), r5)
              r5long = t(r5long)
              dim(r5long) = c((length(r5) * (ws2/ws3)), 1)
              if (nD < length(r5long)) {
                invalid = r5long[1:nD]
              }
              else {
                invalid = c(r5long, rep(0, (nD - length(r5long))))
              }
              rm(r5, rout)
              ND = nD/n_ws3_perday
              if (ND > 0.2) {
                time = as.character(IMP$metashort[1:nD, 1])
                if (length(which(colnames(IMP$metashort) == "anglez")) ==
                    0) {
                  cat("metric anglez was not extracted, please make sure that anglez  is extracted")
                }
                angle = as.numeric(as.matrix(IMP$metashort[1:nD, which(colnames(IMP$metashort) ==
                                                                         "anglez")]))
                ACC = as.numeric(as.matrix(IMP$metashort[1:nD, which(colnames(IMP$metashort) ==
                                                                       acc.metric)]))
                night = rep(0, length(angle))
                if (length(which(is.na(angle) == TRUE)) > 0) {
                  if (which(is.na(angle) == TRUE)[1] == length(angle)) {
                    angle[length(angle)] = angle[length(angle) -
                                                   1]
                  }
                }
                getSleepFromExternalFunction = FALSE
                if (length(myfun) != 0) {
                  if (myfun$colnames == "wake_sleep" & myfun$outputtype ==
                      "character") {
                    getSleepFromExternalFunction = TRUE
                  }
                }
                angle[which(is.na(angle) == T)] = 0
                if (getSleepFromExternalFunction == FALSE) {
                  cnt = 1
                  for (i in timethreshold) {
                    for (j in anglethreshold) {
                      sdl1 = rep(0, length(time))
                      postch = which(abs(diff(angle)) > j)
                      q1 = c()
                      if (length(postch) > 1) {
                        q1 = which(diff(postch) > (i * (60/ws3)))
                      }
                      if (length(q1) > 0) {
                        for (gi in 1:length(q1)) {
                          sdl1[postch[q1[gi]]:postch[q1[gi] + 1]] = 1
                        }
                      }
                      else {
                        if (length(postch) < 10) {
                          sdl1[1:length(sdl1)] = 1
                        }
                        else {
                          sdl1[1:length(sdl1)] = 0
                        }
                      }
                      sleep[, cnt] = sdl1
                      cnt = cnt + 1
                    }
                  }
                  cnt = 1
                  sleep = as.data.frame(sleep, stringsAsFactors = TRUE)
                  for (i in timethreshold) {
                    for (j in anglethreshold) {
                      colnames(sleep)[cnt] = paste("T", i,
                                                   "A", j, sep = "")
                      cnt = cnt + 1
                    }
                  }
                }
                else {
                  sleep[which(M$metashort$wake_sleep == "Sleep")] = 1
                }
                detemout = g.detecmidnight(time, desiredtz, dayborder)
                midnights = detemout$midnights
                midnightsi = detemout$midnightsi
                countmidn = length(midnightsi)
                tib.threshold = sptwindow_HDCZA_end = sptwindow_HDCZA_start = L5list = rep(NA,
                                                                                           countmidn)
                if (countmidn != 0) {
                  if (countmidn == 1) {
                    tooshort = 1
                    lastmidnight = time[length(time)]
                    lastmidnighti = length(time)
                    firstmidnight = time[1]
                    firstmidnighti = 1
                    qqq1 = midnightsi[1] + (twd[1] * (3600/ws3))
                    qqq2 = midnightsi[1] + (twd[2] * (3600/ws3))
                    if (qqq2 > length(time))
                      qqq2 = length(time)
                    if (qqq1 < 1)
                      qqq1 = 1
                    night[qqq1:qqq2] = 1
                    detection.failed = FALSE
                    tmpANGLE = angle[qqq1:qqq2]
                    tmpTIME = time[qqq1:qqq2]
                    inbedout = sptwindow_HDCZA(tmpANGLE, ws3 = ws3,
                                               constrain2range = constrain2range, perc = perc,
                                               inbedthreshold = inbedthreshold, bedblocksize = bedblocksize,
                                               outofbedsize = outofbedsize)
                    if (length(inbedout$sptwindow_HDCZA_end) != 0 &
                        length(inbedout$sptwindow_HDCZA_start) != 0) {
                      if (inbedout$sptwindow_HDCZA_end + qqq1 >=
                          qqq2 - (1 * (3600/ws3))) {
                        daysleep_offset = 6
                        newqqq1 = qqq1 + (daysleep_offset * (3600/ws3))
                        newqqq2 = qqq2 + (daysleep_offset * (3600/ws3))
                        if (newqqq2 > length(angle))
                          newqqq2 = length(angle)
                        if (newqqq1 < length(angle) & (newqqq2 -
                                                       newqqq1) > (23 * (3600/ws3))) {
                          inbedout = sptwindow_HDCZA(angle[newqqq1:newqqq2],
                                                     ws3 = ws3, constrain2range = constrain2range,
                                                     perc = perc, inbedthreshold = inbedthreshold,
                                                     bedblocksize = bedblocksize, outofbedsize = outofbedsize)
                          if (inbedout$sptwindow_HDCZA_start + newqqq1 >=
                              newqqq2) {
                            inbedout$sptwindow_HDCZA_start = (newqqq2 -
                                                                newqqq1) - 1
                          }
                        }
                        else {
                          daysleep_offset = 0
                        }
                      }
                      if (qqq1 == 1) {
                        startTimeRecord = unlist(iso8601chartime2POSIX(IMP$metashort$timestamp[1],
                                                                       tz = desiredtz))
                        startTimeRecord = sum(as.numeric(startTimeRecord[c("hour",
                                                                           "min", "sec")])/c(1, 60, 3600))
                        sptwindow_HDCZA_end[1] = inbedout$sptwindow_HDCZA_end/(3600/ws3) +
                          startTimeRecord
                        sptwindow_HDCZA_start[1] = inbedout$sptwindow_HDCZA_start/(3600/ws3) +
                          startTimeRecord
                      }
                      else {
                        sptwindow_HDCZA_end[1] = (inbedout$sptwindow_HDCZA_end/(3600/ws3)) +
                          12 + daysleep_offset
                        sptwindow_HDCZA_start[1] = (inbedout$sptwindow_HDCZA_start/(3600/ws3)) +
                          12 + daysleep_offset
                      }
                      sptwindow_HDCZA_end[1] = dstime_handling_check(tmpTIME = tmpTIME,
                                                                     inbedout = inbedout, tz = desiredtz, calc_sptwindow_HDCZA_end = sptwindow_HDCZA_end[1],
                                                                     calc_sptwindow_HDCZA_start = sptwindow_HDCZA_start[1])
                      tib.threshold[1] = inbedout$tib.threshold
                    }
                    tmpACC = ACC[qqq1:qqq2]
                    windowRL = round((3600/ws3) * 5)
                    if ((windowRL/2) == round(windowRL/2))
                      windowRL = windowRL + 1
                    if (length(tmpACC) < windowRL) {
                      0
                      cat("Warning: time window shorter than 5 hours which makes it impossible to identify L5")
                      L5 = 0
                    }
                    else {
                      ZRM = zoo::rollmean(x = c(tmpACC), k = windowRL,
                                          fill = "extend", align = "center")
                      L5 = which(ZRM == min(ZRM))[1]
                      if (sd(ZRM) == 0) {
                        L5 = c()
                      }
                      else {
                        L5 = (L5/(3600/ws3)) + 12
                      }
                      if (length(L5) == 0)
                        L5 = 0
                    }
                    L5list[1] = L5
                  }
                  else {
                    cut = which(as.numeric(midnightsi) == 0)
                    if (length(cut) > 0) {
                      midnights = midnights[-cut]
                      midnightsi = midnightsi[-cut]
                    }
                    lastmidnight = midnights[length(midnights)]
                    lastmidnighti = midnightsi[length(midnights)]
                    firstmidnight = midnights[1]
                    firstmidnighti = midnightsi[1]
                    for (j in 1:(countmidn)) {
                      qqq1 = midnightsi[j] + (twd[1] * (3600/ws3))
                      qqq2 = midnightsi[j] + (twd[2] * (3600/ws3))
                      if (qqq2 > length(time))
                        qqq2 = length(time)
                      if (qqq1 < 1)
                        qqq1 = 1
                      night[qqq1:qqq2] = j
                      tmpACC = ACC[qqq1:qqq2]
                      windowRL = round((3600/ws3) * 5)
                      if ((windowRL/2) == round(windowRL/2))
                        windowRL = windowRL + 1
                      ZRM = zoo::rollmean(x = c(tmpACC), k = windowRL,
                                          fill = "extend", align = "center")
                      L5 = which(ZRM == min(ZRM))[1]
                      if (sd(ZRM) == 0) {
                        L5 = c()
                      }
                      else {
                        L5 = (L5/(3600/ws3)) + 12
                      }
                      if (length(L5) == 0)
                        L5 = 0
                      L5list[j] = L5
                      tmpANGLE = angle[qqq1:qqq2]
                      tmpTIME = time[qqq1:qqq2]
                      daysleep_offset = 0
                      inbedout = sptwindow_HDCZA(tmpANGLE, ws3 = ws3,
                                                 constrain2range = constrain2range, perc = perc,
                                                 inbedthreshold = inbedthreshold, bedblocksize = bedblocksize,
                                                 outofbedsize = outofbedsize)
                      if (length(inbedout$sptwindow_HDCZA_end) !=
                          0 & length(inbedout$sptwindow_HDCZA_start) !=
                          0) {
                        if (inbedout$sptwindow_HDCZA_end + qqq1 >=
                            qqq2 - (1 * (3600/ws3))) {
                          daysleep_offset = 6
                          newqqq1 = qqq1 + (daysleep_offset * (3600/ws3))
                          newqqq2 = qqq2 + (daysleep_offset * (3600/ws3))
                          if (newqqq2 > length(angle))
                            newqqq2 = length(angle)
                          if (newqqq1 < length(angle) & (newqqq2 -
                                                         newqqq1) > (23 * (3600/ws3))) {
                            inbedout = sptwindow_HDCZA(angle[newqqq1:newqqq2],
                                                       ws3 = ws3, constrain2range = constrain2range,
                                                       perc = perc, inbedthreshold = inbedthreshold,
                                                       bedblocksize = bedblocksize, outofbedsize = outofbedsize)
                            if (inbedout$sptwindow_HDCZA_start +
                                newqqq1 >= newqqq2) {
                              inbedout$sptwindow_HDCZA_start = (newqqq2 -
                                                                  newqqq1) - 1
                            }
                          }
                          else {
                            daysleep_offset = 0
                          }
                        }
                        if (qqq1 == 1) {
                          startTimeRecord = unlist(iso8601chartime2POSIX(IMP$metashort$timestamp[1],
                                                                         tz = desiredtz))
                          startTimeRecord = sum(as.numeric(startTimeRecord[c("hour",
                                                                             "min", "sec")])/c(1, 60,
                                                                                               3600))
                          sptwindow_HDCZA_end[j] = (inbedout$sptwindow_HDCZA_end/(3600/ws3)) +
                            startTimeRecord + daysleep_offset
                          sptwindow_HDCZA_start[j] = (inbedout$sptwindow_HDCZA_start/(3600/ws3)) +
                            startTimeRecord + daysleep_offset
                        }
                        else {
                          sptwindow_HDCZA_end[j] = (inbedout$sptwindow_HDCZA_end/(3600/ws3)) +
                            12 + daysleep_offset
                          sptwindow_HDCZA_start[j] = (inbedout$sptwindow_HDCZA_start/(3600/ws3)) +
                            12 + daysleep_offset
                        }
                        sptwindow_HDCZA_end[j] = dstime_handling_check(tmpTIME = tmpTIME,
                                                                       inbedout = inbedout, tz = desiredtz, calc_sptwindow_HDCZA_end = sptwindow_HDCZA_end[j],
                                                                       calc_sptwindow_HDCZA_start = sptwindow_HDCZA_start[j])
                        tib.threshold[j] = inbedout$tib.threshold
                      }
                    }
                    detection.failed = FALSE
                  }
                }
                else {
                  cat("No midnights found")
                  detection.failed = TRUE
                }
                metatmp = data.frame(time, invalid, night = night, sleep = sleep,
                                     stringsAsFactors = T)
              }
              else {
                metatmp = c()
                L5list = c()
                sptwindow_HDCZA_end = c()
                sptwindow_HDCZA_start = c()
                tib.threshold = c()
                detection.failed = TRUE
              }
              invisible(list(output = metatmp, detection.failed = detection.failed,
                             L5list = L5list, sptwindow_HDCZA_end = sptwindow_HDCZA_end,
                             sptwindow_HDCZA_start = sptwindow_HDCZA_start, tib.threshold = tib.threshold))
            }
            SLE = g.sib.det2(M, IMP, I, ...)
            ws3 = M$windowsizes[1]
            if (length(SLE$output) > 0 & SLE$detection.failed ==
                FALSE) {
              id = as.character(unlist(strsplit(I$filename,
                                                "_"))[1])
              datename = as.character(unlist(strsplit(as.character(as.matrix(M$metashort[1])),
                                                      " "))[1])
              plottitle = " "
              if (do.pdf == TRUE) {
                pdf(paste(metadatadir, "/meta/sleep.qc/graphperday_id_",
                          id, "_", I$filename, ".pdf",
                          sep = ""), width = 8.2, height = 11.7)
                g.sib.plot(SLE, M, I, plottitle, nightsperpage = nightsperpage,
                           desiredtz = desiredtz)
                dev.off()
              }
              sib.cla.sum = c()

              ##g.sib.sum to ignore short non-wears
              g.sib.sum <- function(SLE, M, ignorenonwear = TRUE, desiredtz = "") {
                A = as.data.frame(SLE$output, stringsAsFactors = TRUE)
                invalid = A$invalid
                if (ignorenonwear == TRUE) {
                  if (length(which(A$invalid == 1)) > 0) {

                    ##remove < 2-hour non-wear intervals
                    invalid_rle <- rle(invalid)
                    invalid_rle$values[which(invalid_rle$values==1 & invalid_rle$lengths<=(60/ws3)*60*nonwearhour)] <- 0
                    invalid2 <- inverse.rle(invalid_rle)
                    A[which(invalid2 == 1), 2:ncol(A)] = 0

                    ##remove nights with h-hour valid data
                    invalid3 <- rle(A$night)
                    if(length(which(invalid3$values!=0 & invalid3$lengths<(60/ws3)*60*ninvalid))>0) {
                      invalid3$values[which(invalid3$values!=0 & invalid3$lengths<(60/ws3)*60*ninvalid)] <- 0
                      A$night <- inverse.rle(invalid3)
                      A[which(A$night == 0), 2:ncol(A)] = 0

                    }
                    invalid = ifelse(A$night == 0, 1, 0)
                  }
                }

                space = ifelse(length(unlist(strsplit(as.character(A$time[1]),
                                                      " "))) > 1, TRUE, FALSE)
                temptime = as.character(unlist(A$time))
                if (space == FALSE) {
                  time = temptime
                } else {
                  time = as.POSIXlt(temptime, tz = desiredtz)
                  time = POSIXtime2iso8601(time, tz = desiredtz)
                }
                night = A$night
                sleep = as.data.frame(as.matrix(A[, (which(colnames(A) ==
                                                             "night") + 1):ncol(A)]), stringsAsFactors = TRUE)
                colnames(sleep) = colnames(A)[(which(colnames(A) == "night") +
                                                 1):ncol(A)]
                ws3 = M$windowsizes[1]
                ws2 = M$windowsizes[2]
                sib.cla.sum = as.data.frame(matrix(0, 0, 9))
                cnt = 1
                un = unique(night)
                if (length(which(un == 0 | is.na(un) == TRUE)) > 0) {
                  un = un[-c(which(un == 0 | is.na(un) == TRUE))]
                }
                if (length(un) != 0) {
                  if (is.numeric(max(un)) == TRUE) {
                    for (i in 1:max(un)) {
                      qqq1 = which(night == i)[1]
                      qqq2 = which(night == i)[length(which(night ==
                                                              i))]
                      if (length(qqq1) == 1 & length(qqq2) == 1) {
                        time.t = time[qqq1:qqq2]
                        sleep.t = as.data.frame(sleep[qqq1:qqq2, ],
                                                stringsAsFactors = TRUE)
                        colnames(sleep.t) = colnames(sleep)
                        invalid.t = invalid[qqq1:qqq2]
                        for (j in 1:ncol(sleep.t)) {
                          nsleepperiods = length(which(diff(sleep.t[,
                                                                    j]) == 1))
                          if (nsleepperiods > 0) {
                            start_sp = which(diff(sleep.t[, j]) ==
                                               1)
                            end_sp = which(diff(sleep.t[, j]) == -1)
                            if (length(end_sp) == 0)
                              end_sp = nrow(sleep.t)
                            if (start_sp[1] > end_sp[1]) {
                              start_sp = c(1, start_sp)
                            }
                            if (start_sp[length(start_sp)] > end_sp[length(end_sp)]) {
                              end_sp = c(end_sp, nrow(sleep.t))
                            }
                            nsleepperiods = length(start_sp)
                          }
                          if (nsleepperiods == 0) {
                            sleep_dur = 0
                            nint = 0
                            lex = 1
                            colnames(sib.cla.sum)[lex:(lex + 3)] = c("night",
                                                                     "definition", "start.time.day",
                                                                     "nsib.periods")
                            sib.cla.sum[cnt, lex] = i
                            sib.cla.sum[cnt, (lex + 1)] = colnames(sleep.t)[j]
                            sib.cla.sum[cnt, (lex + 2)] = as.character(time.t[1])
                            sib.cla.sum[cnt, (lex + 3)] = 0
                            lex = lex + 4
                            colnames(sib.cla.sum)[lex:(lex + 1)] = c("tot.sib.dur.hrs",
                                                                     "fraction.night.invalid")
                            sib.cla.sum[cnt, lex] = 0
                            sib.cla.sum[cnt, (lex + 1)] = length(which(invalid.t !=
                                                                         0))/length(invalid.t)
                            lex = lex + 2
                            colnames(sib.cla.sum)[lex:(lex + 2)] = c("sib.period",
                                                                     "sib.onset.time", "sib.end.time")
                            sib.cla.sum[cnt, lex] = 0
                            sib.cla.sum[cnt, (lex + 1)] = ""
                            sib.cla.sum[cnt, (lex + 2)] = ""
                            cnt = cnt + 1
                          } else {
                            for (spi in 1:nsleepperiods) {
                              sleep_sp = sleep.t[start_sp[spi]:end_sp[spi],
                                                 j]
                              time_sp = time.t[start_sp[spi]:end_sp[spi]]
                              sleep_dur = (round((length(which(sleep_sp ==
                                                                 1))/(60/ws3)) * 100))/100
                              lex = 1
                              colnames(sib.cla.sum)[lex:(lex + 3)] = c("night",
                                                                       "definition", "start.time.day",
                                                                       "nsib.periods")
                              sib.cla.sum[cnt, lex] = i
                              sib.cla.sum[cnt, (lex + 1)] = colnames(sleep.t)[j]
                              sib.cla.sum[cnt, (lex + 2)] = as.character(time.t[1])
                              sib.cla.sum[cnt, (lex + 3)] = nsleepperiods
                              lex = lex + 4
                              colnames(sib.cla.sum)[lex:(lex + 1)] = c("tot.sib.dur.hrs",
                                                                       "fraction.night.invalid")
                              sib.cla.sum[cnt, lex] = sleep_dur/60
                              sib.cla.sum[cnt, (lex + 1)] = length(which(invalid.t !=
                                                                           0))/length(invalid.t)
                              lex = lex + 2
                              colnames(sib.cla.sum)[lex:(lex + 2)] = c("sib.period",
                                                                       "sib.onset.time", "sib.end.time")
                              sib.cla.sum[cnt, lex] = spi
                              sib.cla.sum[cnt, (lex + 1)] = as.character(time_sp[which(sleep_sp ==
                                                                                         1)[1]])
                              sib.cla.sum[cnt, (lex + 2)] = as.character(time_sp[length(sleep_sp)])
                              cnt = cnt + 1
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return(sib.cla.sum)
              }

              sib.cla.sum = g.sib.sum(SLE, M, ignorenonwear = ignorenonwear,
                                      desiredtz = desiredtz)

              deltaanglez <- M$metashort$anglez-c(0,M$metashort$anglez[-nrow(M$metashort)])
              bwidth <- (60/ws3)*5*6
              sumabschange <- sapply(1:(nrow(M$metashort)/(bwidth)),function(i) sum(abs(deltaanglez[((i-1)*bwidth+1):(i*bwidth)])))

              m1 <- depmix(y~1,ns=2,family=gaussian(),data=data.frame(y=sumabschange))
              fm1 <- fit(m1,em=em.control(maxit=1000))

              if(fm1@response[[1]][[1]]@parameters$coefficients > fm1@response[[2]][[1]]@parameters$coefficients) {
                state <- fm1@posterior$state
              } else {
                state <- ifelse(fm1@posterior$state==2,1,2)
              }

              tmp_rle <- rle(state)
              while(sum(tmp_rle$lengths<=2)>0) {
                tmp_rle$values[which.min(tmp_rle$lengths)] <- switch(tmp_rle$values[which.min(tmp_rle$lengths)],2,1)
                tmp_rle <- rle(inverse.rle(tmp_rle))
              }
              state <- inverse.rle(tmp_rle)

              tmp_timestamp <- M$metashort$timestamp
              tmp_timestamp <- c(tmp_timestamp,tmp_timestamp[length(tmp_timestamp)])
              df_state <- data.frame(time=tmp_timestamp[(1:(nrow(M$metashort)/(bwidth)))*bwidth+1],
                                     night=SLE$output$night[(1:(nrow(M$metashort)/(bwidth)))*bwidth],state=state)

              A.ori = as.data.frame(SLE$output, stringsAsFactors = TRUE)
              A = as.data.frame(SLE$output, stringsAsFactors = TRUE)
              invalid = A$invalid
              if (ignorenonwear == TRUE) {
                if (length(which(A$invalid == 1)) > 0) {

                  invalid_rle <- rle(invalid)
                  invalid_rle$values[which(invalid_rle$values==1 & invalid_rle$lengths<=(60/ws3)*60*nonwearhour)] <- 0
                  invalid2 <- inverse.rle(invalid_rle)
                  A[which(invalid2 == 1), 2:ncol(A)] = 0

                  invalid3 <- rle(A$night)
                  if(length(which(invalid3$values!=0 & invalid3$lengths<(60/ws3)*60*ninvalid))>0) {
                    invalid3$values[which(invalid3$values!=0 & invalid3$lengths<(60/ws3)*60*ninvalid)] <- 0
                    A$night <- inverse.rle(invalid3)
                    A[which(A$night == 0), 2:ncol(A)] = 0

                  }
                  invalid = ifelse(A$night == 0, 1, 0)
                }
              }
              df_state$night_clean <- A$night[(1:(nrow(M$metashort)/(bwidth)))*bwidth]

              index_all <- unique(SLE$output$night)
              index_all <- index_all[index_all!=0]
              index_valid <- unique(A$night)
              index_valid <- index_valid[index_valid!=0]
              #index_night <- SLE$output$night[(1:(nrow(M$metashort)/(bwidth)))*bwidth]

              ##helpful functions
              index2time24 <- function(x) {
                timeRecord <- unlist(as.POSIXlt(x, format = "%Y-%m-%dT%H:%M:%S",""))
                return(sum(as.numeric(timeRecord[c("hour",
                                                   "min", "sec")])/c(1, 60, 3600)))
              }
              Index2time24 <- Vectorize(index2time24,vec="x")

              tmp_end <- tmp_start <- c()
              for(i in index_all) {
                if(i %in% index_valid) {
                  df_select <- df_state[df_state$night_clean==i,]
                  one_night <- df_select$state
                  night_rle <- rle(one_night)
                  while(length(night_rle$lengths)>3) {
                    night_rle$values[which.min(night_rle$lengths)] <- switch(night_rle$values[which.min(night_rle$lengths)],2,1)
                    night_rle <- rle(inverse.rle(night_rle))
                  }

                  night_cumsum <- cumsum(night_rle$lengths)
                  t_end <- Index2time24(df_select$time[night_cumsum[which(night_rle$values==2)][1]])+24
                  t_start <- Index2time24(df_select$time[night_cumsum[which(night_rle$values==1)][1]])

                  if(i==max(index_all) & !is.null(lastdayend)) t_end <- min(24+lastdayend,t_end)
                  tmp_end <- c(tmp_end,t_end)
                  tmp_start <- c(tmp_start,t_start)


                } else {
                  df_select <- df_state[df_state$night==i,]
                  tmp_end <- c(tmp_end,33) #42; 9am
                  tmp_start <- c(tmp_start,20) #16; 8pm
                }
              }

              marker_start <- tmp_start
              marker_end <- tmp_end

              if(!is.null(startearly)) {
                marker_start[which(marker_start<(startearly))] <- startearly
              }

              if(!is.null(endearly)) {
                marker_end[which(marker_end<(24+endearly))] <- 24+endearly
              }

              L5list = SLE$L5list
              sptwindow_HDCZA_end_ori = SLE$sptwindow_HDCZA_end
              sptwindow_HDCZA_start_ori = SLE$sptwindow_HDCZA_start
              sptwindow_HDCZA_end = marker_end
              sptwindow_HDCZA_start = marker_start

              sptwindow_HDCZA_start[which(sptwindow_HDCZA_start<19)] <- 19
              sptwindow_HDCZA_end[which(sptwindow_HDCZA_end>33)] <- 34

              tib.threshold = SLE$tib.threshold

              save(sib.cla.sum, L5list, sptwindow_HDCZA_end, A, A.ori,
                   sptwindow_HDCZA_start, tib.threshold,
                   sptwindow_HDCZA_end_ori, sptwindow_HDCZA_start_ori,
                   file = paste(metadatadir, "/meta/ms3.out.new/",
                                fname, ".RData", sep = ""))
            }
          }
        }
      })
      return(tryCatchResult)
    }
  if (do.parallel == TRUE) {
    on.exit(parallel::stopCluster(cl))
    for (oli in 1:length(output_list)) {
      if (is.null(unlist(output_list[oli])) == FALSE) {
        cat(paste0("\nErrors and warnings for ",
                   fnames[oli]))
        print(unlist(output_list[oli]))
      }
    }
  }
}
